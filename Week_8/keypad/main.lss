
main.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000770  00000000  00000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000004  40000000  40000000  00008770  2**2
                  ALLOC
  2 .stack        00000400  40000100  40000100  00008770  2**3
                  CONTENTS
  3 .comment      00000086  00000000  00000000  00008b70  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000000d8  00000000  00000000  00008bf8  2**3
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_pubnames 000000e6  00000000  00000000  00008cd0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000049e  00000000  00000000  00008db6  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000151  00000000  00000000  00009254  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000027c  00000000  00000000  000093a5  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000178  00000000  00000000  00009624  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000000a  00000000  00000000  0000979c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000243  00000000  00000000  000097a6  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <Vectors>:
@  Mapped to Address 0.
@  Absolute addressing mode must be used.
@  Dummy Handlers are implemented as infinite loops which can be modified.

Vectors:        LDR     PC, Reset_Addr         
   0:	e59ff018 	ldr	pc, [pc, #24]	; 20 <Reset_Addr>
                LDR     PC, Undef_Addr
   4:	e59ff018 	ldr	pc, [pc, #24]	; 24 <Undef_Addr>
                LDR     PC, SWI_Addr
   8:	e59ff018 	ldr	pc, [pc, #24]	; 28 <SWI_Addr>
                LDR     PC, PAbt_Addr
   c:	e59ff018 	ldr	pc, [pc, #24]	; 2c <PAbt_Addr>
                LDR     PC, DAbt_Addr
  10:	e59ff018 	ldr	pc, [pc, #24]	; 30 <DAbt_Addr>
                NOP                            @ Reserved Vector 
  14:	e1a00000 	nop			(mov r0,r0)
                LDR     PC, IRQ_Addr
  18:	e59ff018 	ldr	pc, [pc, #24]	; 38 <IRQ_Addr>
@@                LDR     PC, [PC, #-0x0120]     @ Vector from VicVectAddr
                LDR     PC, FIQ_Addr
  1c:	e59ff018 	ldr	pc, [pc, #24]	; 3c <FIQ_Addr>

00000020 <Reset_Addr>:
  20:	00000054 	andeq	r0, r0, r4, asr r0

00000024 <Undef_Addr>:
  24:	00000040 	andeq	r0, r0, r0, asr #32

00000028 <SWI_Addr>:
  28:	00000044 	andeq	r0, r0, r4, asr #32

0000002c <PAbt_Addr>:
  2c:	00000048 	andeq	r0, r0, r8, asr #32

00000030 <DAbt_Addr>:
  30:	0000004c 	andeq	r0, r0, ip, asr #32
  34:	b9206e28 	stmltdb	r0!, {r3, r5, r9, sl, fp, sp, lr}

00000038 <IRQ_Addr>:
  38:	000000fc 	streqd	r0, [r0], -ip

0000003c <FIQ_Addr>:
  3c:	00000050 	andeq	r0, r0, r0, asr r0

00000040 <Undef_Handler>:

Reset_Addr:      .word     Reset_Handler
Undef_Addr:      .word     Undef_Handler
SWI_Addr:        .word     SWI_Handler
PAbt_Addr:       .word     PAbt_Handler
DAbt_Addr:       .word     DAbt_Handler
                 .word     0xB9206E28             @ Reserved Address 
IRQ_Addr:        .word     IRQ_Handler
FIQ_Addr:        .word     FIQ_Handler

Undef_Handler:   B       Undef_Handler
  40:	eafffffe 	b	40 <F_Bit>

00000044 <SWI_Handler>:
@@ SWI_Handler:     B       SWI_Handler
.extern SoftwareInterrupt
SWI_Handler:     B       SoftwareInterrupt  @ see swi_handler.S
  44:	ea000046 	b	164 <SoftwareInterrupt>

00000048 <PAbt_Handler>:
PAbt_Handler:    B       PAbt_Handler
  48:	eafffffe 	b	48 <PAbt_Handler>

0000004c <DAbt_Handler>:
DAbt_Handler:    B       DAbt_Handler
  4c:	eafffffe 	b	4c <DAbt_Handler>

00000050 <FIQ_Handler>:
@@ handled thru assembler wrapper (see below)
@@ IRQ_Handler:    B       IRQ_Handler
FIQ_Handler:     B       FIQ_Handler
  50:	eafffffe 	b	50 <FIQ_Handler>

00000054 <Reset_Handler>:


@ Reset Handler
@                EXPORT  Reset_Handler
.global Reset_handler
Reset_Handler:

@  Call low-level init C-function
@                IMPORT TargetResetInit
@                BL   TargetResetInit

                 .extern TargetResetInit
                 ldr     SP, =Stack_Top    @ temporary stack at Stack_Top
  54:	e59fd0e4 	ldr	sp, [pc, #228]	; 140 <.text+0x140>
                 LDR R0, =TargetResetInit
  58:	e59f00e4 	ldr	r0, [pc, #228]	; 144 <.text+0x144>
                 MOV LR, PC
  5c:	e1a0e00f 	mov	lr, pc
                 BX R0
  60:	e12fff10 	bx	r0


@  Setup Stack for each mode
                LDR     R0, =Stack_Top
  64:	e59f00d4 	ldr	r0, [pc, #212]	; 140 <.text+0x140>

@  Enter Undefined Instruction Mode and set its Stack Pointer
                MSR     CPSR_c, #Mode_UND | I_Bit | F_Bit
  68:	e321f0db 	msr	CPSR_c, #219	; 0xdb
                MOV     SP, R0
  6c:	e1a0d000 	mov	sp, r0
                SUB     R0, R0, #UND_Stack_Size
  70:	e2400000 	sub	r0, r0, #0	; 0x0

@  Enter Abort Mode and set its Stack Pointer
                MSR     CPSR_c, #Mode_ABT | I_Bit | F_Bit
  74:	e321f0d7 	msr	CPSR_c, #215	; 0xd7
                MOV     SP, R0
  78:	e1a0d000 	mov	sp, r0
                SUB     R0, R0, #ABT_Stack_Size
  7c:	e2400000 	sub	r0, r0, #0	; 0x0

@  Enter FIQ Mode and set its Stack Pointer
                MSR     CPSR_c, #Mode_FIQ | I_Bit | F_Bit
  80:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
                MOV     SP, R0
  84:	e1a0d000 	mov	sp, r0
                SUB     R0, R0, #FIQ_Stack_Size
  88:	e2400000 	sub	r0, r0, #0	; 0x0

@  Enter IRQ Mode and set its Stack Pointer
                MSR     CPSR_c, #Mode_IRQ | I_Bit | F_Bit
  8c:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
                MOV     SP, R0
  90:	e1a0d000 	mov	sp, r0
                SUB     R0, R0, #IRQ_Stack_Size
  94:	e2400c01 	sub	r0, r0, #256	; 0x100

@  Enter Supervisor Mode and set its Stack Pointer
                MSR     CPSR_c, #Mode_SVC | I_Bit | F_Bit
  98:	e321f0d3 	msr	CPSR_c, #211	; 0xd3
                MOV     SP, R0
  9c:	e1a0d000 	mov	sp, r0
                SUB     R0, R0, #SVC_Stack_Size
  a0:	e2400c01 	sub	r0, r0, #256	; 0x100

@  Enter User Mode and set its Stack Pointer
@  mt:          MSR     CPSR_c, #Mode_USR
                MSR     CPSR_c, #Mode_USR | I_Bit
  a4:	e321f090 	msr	CPSR_c, #144	; 0x90
                MOV     SP, R0
  a8:	e1a0d000 	mov	sp, r0
                SUB     SL, SP, #USR_Stack_Size
  ac:	e24dac02 	sub	sl, sp, #512	; 0x200
@  mt: Start application in USR-mode with IRQ-exceptions disabled.
@  They can be enabled at runtime thru IntEnable in swi.h/swi_handler.S.

@  Relocate .data section (Copy from ROM to RAM)
                LDR     R1, =_etext 
  b0:	e59f1090 	ldr	r1, [pc, #144]	; 148 <.text+0x148>
                LDR     R2, =_data 
  b4:	e59f2090 	ldr	r2, [pc, #144]	; 14c <.text+0x14c>
                LDR     R3, =_edata 
  b8:	e59f3090 	ldr	r3, [pc, #144]	; 150 <.text+0x150>
                CMP     R2, R3
  bc:	e1520003 	cmp	r2, r3
                BEQ     DataIsEmpty
  c0:	0a000003 	beq	d4 <DataIsEmpty>

000000c4 <LoopRel>:
LoopRel:        CMP     R2, R3 
  c4:	e1520003 	cmp	r2, r3
                LDRLO   R0, [R1], #4 
  c8:	34910004 	ldrcc	r0, [r1], #4
                STRLO   R0, [R2], #4 
  cc:	34820004 	strcc	r0, [r2], #4
                BLO     LoopRel 
  d0:	3afffffb 	bcc	c4 <LoopRel>

000000d4 <DataIsEmpty>:
DataIsEmpty:
 
@  Clear .bss section (Zero init)
                MOV     R0, #0 
  d4:	e3a00000 	mov	r0, #0	; 0x0
                LDR     R1, =__bss_start__ 
  d8:	e59f1074 	ldr	r1, [pc, #116]	; 154 <.text+0x154>
                LDR     R2, =__bss_end__ 
  dc:	e59f2074 	ldr	r2, [pc, #116]	; 158 <.text+0x158>
                CMP     R1,R2
  e0:	e1510002 	cmp	r1, r2
                BEQ     BSSIsEmpty
  e4:	0a000002 	beq	f4 <BSSIsEmpty>

000000e8 <LoopZI>:
LoopZI:         CMP     R1, R2 
  e8:	e1510002 	cmp	r1, r2
                STRLO   R0, [R1], #4 
  ec:	34810004 	strcc	r0, [r1], #4
                BLO     LoopZI 
  f0:	3afffffc 	bcc	e8 <LoopZI>

000000f4 <BSSIsEmpty>:
BSSIsEmpty:


@  Enter the C code
@                IMPORT  __main
@                LDR     R0, =__main
                .extern main
                LDR R0, =main
  f4:	e59f0060 	ldr	r0, [pc, #96]	; 15c <.text+0x15c>
                BX      R0
  f8:	e12fff10 	bx	r0

000000fc <IRQ_Handler>:


@ User Initial Stack & Heap (not used in GNU port)
@@                AREA    |.text|, CODE, READONLY

@@                IMPORT  __use_two_region_memory
@@                EXPORT  __user_initial_stackheap
@@__user_initial_stackheap

@@                LDR     R0, =  Heap_Mem
@@                LDR     R1, =(Stack_Mem + USR_Stack_Size)
@@                LDR     R2, = (Heap_Mem +      Heap_Size)
@@                LDR     R3, = Stack_Mem
@@                BX      LR


@@ IRQ_Wrapper based on Examples for
@@ AT91-ARM7TDMI AIC from Atmel,
@@ adapted to LPC23xx/24xx VIC by M. Thomas
@@ This wrapper avoids compiler-dependencies.

.set LPC_BASE_VIC, 0xFFFFF000
.set VIC_VectAddr, 0xF00

.arm
IRQ_Handler:

@- Manage Exception Entry
@- Adjust and save LR_irq in IRQ stack
            sub         lr, lr, #4
  fc:	e24ee004 	sub	lr, lr, #4	; 0x4
            stmfd       sp!, {lr}
 100:	e92d4000 	stmdb	sp!, {lr}

@- Save SPSR need to be saved for nested interrupt
            mrs         r14, SPSR
 104:	e14fe000 	mrs	lr, SPSR
            stmfd       sp!, {r14}
 108:	e92d4000 	stmdb	sp!, {lr}

@- Save and r0 in IRQ stack
            stmfd       sp!, {r0}
 10c:	e92d0001 	stmdb	sp!, {r0}

@- Load the ISR-Address from VICVectAddr
            ldr         r14, =LPC_BASE_VIC
 110:	e59fe048 	ldr	lr, [pc, #72]	; 160 <.text+0x160>
            ldr         r0 , [r14, #VIC_VectAddr]
 114:	e59e0f00 	ldr	r0, [lr, #3840]

@- Enable Interrupt and Switch in Supervisor Mode
           msr         CPSR_c, #Mode_SVC
 118:	e321f013 	msr	CPSR_c, #19	; 0x13

@- Save scratch/used registers and LR in User Stack
            stmfd       sp!, { r1-r3, r12, r14 }
 11c:	e92d500e 	stmdb	sp!, {r1, r2, r3, ip, lr}

@- Branch to the routine pointed by the VIC_VectAddr
            mov         r14, pc
 120:	e1a0e00f 	mov	lr, pc
            bx          r0
 124:	e12fff10 	bx	r0

@- Restore scratch/used registers and LR from User Stack
            ldmia       sp!, { r1-r3, r12, r14 }
 128:	e8bd500e 	ldmia	sp!, {r1, r2, r3, ip, lr}

@- Disable Interrupt and switch back in IRQ mode
            msr         CPSR_c, #I_Bit | Mode_IRQ
 12c:	e321f092 	msr	CPSR_c, #146	; 0x92

@-  Mark the End of Interrupt on the VIC
@   by writing to VICVectAddr - not needed 
@   here since already done in the ISRs
@@           ldr         r14, =LPC_BASE_VIC
@@           str         r14, [r14, #VIC_VectAddr]

@- Restore R0
            ldmia       sp!, {r0}
 130:	e8bd0001 	ldmia	sp!, {r0}

@- Restore SPSR_irq and r0 from IRQ stack
            ldmia       sp!, {r14}
 134:	e8bd4000 	ldmia	sp!, {lr}
            msr         SPSR_cxsf, r14
 138:	e16ff00e 	msr	SPSR_fsxc, lr

@- Restore adjusted  LR_irq from IRQ stack directly in the PC
            ldmia       sp!, {pc}^
 13c:	e8fd8000 	ldmia	sp!, {pc}^
 140:	40000500 	andmi	r0, r0, r0, lsl #10
 144:	00000635 	andeq	r0, r0, r5, lsr r6
 148:	00000770 	andeq	r0, r0, r0, ror r7
 14c:	40000000 	andmi	r0, r0, r0
 150:	00000770 	andeq	r0, r0, r0, ror r7
 154:	40000000 	andmi	r0, r0, r0
 158:	40000004 	andmi	r0, r0, r4
 15c:	0000047d 	andeq	r0, r0, sp, ror r4
 160:	fffff000 	undefined instruction 0xfffff000

00000164 <SoftwareInterrupt>:
@*           (not thumb). This is the case if the functions below  *
@*           (IntEnable/IntDisable) get used.
@********************************************************************
SoftwareInterrupt:
	LDR		R0, [LR, #-4]          /* get swi instruction code (ARM-mode) */
 164:	e51e0004 	ldr	r0, [lr, #-4]
	BIC		R0, R0, #0xff000000    /* clear top 8 bits leaving swi "comment field"=number */
 168:	e3c004ff 	bic	r0, r0, #-16777216	; 0xff000000
	CMP		R0, #4                 /* range check */
 16c:	e3500004 	cmp	r0, #4	; 0x4
	LDRLO	PC, [PC, R0, LSL #2]   /* get jump-address from table */
 170:	379ff100 	ldrcc	pc, [pc, r0, lsl #2]
	MOVS	PC, LR                 /* if out of range: do nothing and return */
 174:	e1b0f00e 	movs	pc, lr

00000178 <SwiFunction>:
 178:	00000188 	andeq	r0, r0, r8, lsl #3
 17c:	00000198 	muleq	r0, r8, r1
 180:	000001a8 	andeq	r0, r0, r8, lsr #3
 184:	000001b8 	streqh	r0, [r0], -r8

00000188 <IRQDisable>:

SwiFunction:
.word IRQDisable
.word IRQEnable
.word FIQDisable
.word FIQEnable

IRQDisable:
	MRS		R0, SPSR
 188:	e14f0000 	mrs	r0, SPSR
	ORR		R0, R0, #I_Bit
 18c:	e3800080 	orr	r0, r0, #128	; 0x80
	MSR		SPSR_c, R0
 190:	e161f000 	msr	SPSR_c, r0
	MOVS	PC, LR
 194:	e1b0f00e 	movs	pc, lr

00000198 <IRQEnable>:

IRQEnable:
	MRS		R0, SPSR
 198:	e14f0000 	mrs	r0, SPSR
	BIC		R0, R0, #I_Bit
 19c:	e3c00080 	bic	r0, r0, #128	; 0x80
	MSR		SPSR_c, R0
 1a0:	e161f000 	msr	SPSR_c, r0
	MOVS	PC, LR
 1a4:	e1b0f00e 	movs	pc, lr

000001a8 <FIQDisable>:

FIQDisable:
	MRS		R0, SPSR
 1a8:	e14f0000 	mrs	r0, SPSR
	ORR		R0, R0, #F_Bit
 1ac:	e3800040 	orr	r0, r0, #64	; 0x40
	MSR		SPSR_c, R0
 1b0:	e161f000 	msr	SPSR_c, r0
	MOVS	PC, LR
 1b4:	e1b0f00e 	movs	pc, lr

000001b8 <FIQEnable>:

FIQEnable:
	MRS		R0, SPSR
 1b8:	e14f0000 	mrs	r0, SPSR
	BIC		R0, R0, #F_Bit
 1bc:	e3c00040 	bic	r0, r0, #64	; 0x40
	MSR		SPSR_c, R0
 1c0:	e161f000 	msr	SPSR_c, r0
	MOVS	PC, LR
 1c4:	e1b0f00e 	movs	pc, lr

000001c8 <IntEnable>:

@**********************************************************************
@*  Call SWI to enable IRQ                                            *
@*  Function : void IntEnable(void)                                   *
@*  Parameters:      None                                             *
@*  input  :         None                                             * 
@*  output :         None                                             *
@**********************************************************************
IntEnable:
	SWI     SWI_IRQ_EN
 1c8:	ef000001 	svc	0x00000001
	BX      lr
 1cc:	e12fff1e 	bx	lr

000001d0 <IntDisable>:
@ end of IntEnable

@**********************************************************************
@*  Call SWI to disable IRQ                                           *
@*  Function : void IntDisable(void)                                  *
@*  Parameters     : None                                             *
@*  input          : None                                             * 
@*  output         : None                                             *
@**********************************************************************
IntDisable:
	SWI     SWI_IRQ_DIS
 1d0:	ef000000 	svc	0x00000000
	BX      lr
 1d4:	e12fff1e 	bx	lr

000001d8 <delay>:
#include "LPC23xx.h"
void delay(void)
{
 1d8:	b580      	push	{r7, lr}
 1da:	b082      	sub	sp, #8
 1dc:	af00      	add	r7, sp, #0
	for(int i=0;i<0x7f;i++)
 1de:	1c3a      	adds	r2, r7, #0
 1e0:	2300      	movs	r3, #0
 1e2:	6013      	str	r3, [r2, #0]
 1e4:	e011      	b.n	20a <USR_Stack_Size+0xa>
	for(int j=0;j<0xff;j++);
 1e6:	1d3a      	adds	r2, r7, #4
 1e8:	2300      	movs	r3, #0
 1ea:	6013      	str	r3, [r2, #0]
 1ec:	e004      	b.n	1f8 <delay+0x20>
 1ee:	1d3a      	adds	r2, r7, #4
 1f0:	1d3b      	adds	r3, r7, #4
 1f2:	681b      	ldr	r3, [r3, #0]
 1f4:	3301      	adds	r3, #1
 1f6:	6013      	str	r3, [r2, #0]
 1f8:	1d3b      	adds	r3, r7, #4
 1fa:	681b      	ldr	r3, [r3, #0]
 1fc:	2bfe      	cmp	r3, #254
 1fe:	ddf6      	ble.n	1ee <delay+0x16>
 200:	1c3a      	adds	r2, r7, #0
 202:	1c3b      	adds	r3, r7, #0
 204:	681b      	ldr	r3, [r3, #0]
 206:	3301      	adds	r3, #1
 208:	6013      	str	r3, [r2, #0]
 20a:	1c3b      	adds	r3, r7, #0
 20c:	681b      	ldr	r3, [r3, #0]
 20e:	2b7e      	cmp	r3, #126
 210:	dde9      	ble.n	1e6 <delay+0xe>
}
 212:	46bd      	mov	sp, r7
 214:	b002      	add	sp, #8
 216:	bc80      	pop	{r7}
 218:	bc01      	pop	{r0}
 21a:	4700      	bx	r0

0000021c <key_routine>:
void key_routine(void)
 {
 21c:	b580      	push	{r7, lr}
 21e:	b081      	sub	sp, #4
 220:	af00      	add	r7, sp, #0
    unsigned int key;
    FIO3DIR  = 0X008000FF;
 222:	4a82      	ldr	r2, [pc, #520]	(42c <.text+0x42c>)
 224:	4b82      	ldr	r3, [pc, #520]	(430 <.text+0x430>)
 226:	6013      	str	r3, [r2, #0]
    PINSEL0 |=0X00000000;
 228:	4a82      	ldr	r2, [pc, #520]	(434 <.text+0x434>)
 22a:	4b82      	ldr	r3, [pc, #520]	(434 <.text+0x434>)
 22c:	681b      	ldr	r3, [r3, #0]
 22e:	6013      	str	r3, [r2, #0]
    IODIR0  |=0X00000000;
 230:	4a81      	ldr	r2, [pc, #516]	(438 <.text+0x438>)
 232:	4b81      	ldr	r3, [pc, #516]	(438 <.text+0x438>)
 234:	681b      	ldr	r3, [r3, #0]
 236:	6013      	str	r3, [r2, #0]
    while(1)
    {
 	  //First Row      
	      FIO4SET = 0X00000e00;
 238:	4a80      	ldr	r2, [pc, #512]	(43c <.text+0x43c>)
 23a:	23e0      	movs	r3, #224
 23c:	011b      	lsls	r3, r3, #4
 23e:	6013      	str	r3, [r2, #0]
	      key = FIO4PIN;
 240:	4b7f      	ldr	r3, [pc, #508]	(440 <.text+0x440>)
 242:	1c3a      	adds	r2, r7, #0
 244:	681b      	ldr	r3, [r3, #0]
 246:	6013      	str	r3, [r2, #0]
	      key = (key & 0xf000) >> 12 ;
 248:	1c3b      	adds	r3, r7, #0
 24a:	681a      	ldr	r2, [r3, #0]
 24c:	23f0      	movs	r3, #240
 24e:	021b      	lsls	r3, r3, #8
 250:	4013      	ands	r3, r2
 252:	1c3a      	adds	r2, r7, #0
 254:	0b1b      	lsrs	r3, r3, #12
 256:	6013      	str	r3, [r2, #0]
      
              if((key==0x07))
 258:	1c3b      	adds	r3, r7, #0
 25a:	681b      	ldr	r3, [r3, #0]
 25c:	2b07      	cmp	r3, #7
 25e:	d105      	bne.n	26c <key_routine+0x50>
	      {
        	  send_serial_data('0');
 260:	2030      	movs	r0, #48
 262:	f000 f8f3 	bl	44c <send_serial_data>
		  FIO3PIN = 0X00000000;
 266:	4a77      	ldr	r2, [pc, #476]	(444 <.text+0x444>)
 268:	2300      	movs	r3, #0
 26a:	6013      	str	r3, [r2, #0]
	      }
	      if((key==0x0b))
 26c:	1c3b      	adds	r3, r7, #0
 26e:	681b      	ldr	r3, [r3, #0]
 270:	2b0b      	cmp	r3, #11
 272:	d105      	bne.n	280 <key_routine+0x64>
              {
		  send_serial_data('1');
 274:	2031      	movs	r0, #49
 276:	f000 f8e9 	bl	44c <send_serial_data>
		  FIO3PIN = 0X00000001;
 27a:	4a72      	ldr	r2, [pc, #456]	(444 <.text+0x444>)
 27c:	2301      	movs	r3, #1
 27e:	6013      	str	r3, [r2, #0]
	      }
	      if( (key==0x0d))
 280:	1c3b      	adds	r3, r7, #0
 282:	681b      	ldr	r3, [r3, #0]
 284:	2b0d      	cmp	r3, #13
 286:	d105      	bne.n	294 <key_routine+0x78>
              {
	          send_serial_data('2');
 288:	2032      	movs	r0, #50
 28a:	f000 f8df 	bl	44c <send_serial_data>
	          FIO3PIN = 0X00000002;
 28e:	4a6d      	ldr	r2, [pc, #436]	(444 <.text+0x444>)
 290:	2302      	movs	r3, #2
 292:	6013      	str	r3, [r2, #0]
              }
	      if((key==0x0e))
 294:	1c3b      	adds	r3, r7, #0
 296:	681b      	ldr	r3, [r3, #0]
 298:	2b0e      	cmp	r3, #14
 29a:	d105      	bne.n	2a8 <key_routine+0x8c>
	      {
		  send_serial_data('3');
 29c:	2033      	movs	r0, #51
 29e:	f000 f8d5 	bl	44c <send_serial_data>
	          FIO3PIN = 0X00000003;
 2a2:	4a68      	ldr	r2, [pc, #416]	(444 <.text+0x444>)
 2a4:	2303      	movs	r3, #3
 2a6:	6013      	str	r3, [r2, #0]
              }
              FIO4CLR = 0X00000e00;
 2a8:	4a67      	ldr	r2, [pc, #412]	(448 <.text+0x448>)
 2aa:	23e0      	movs	r3, #224
 2ac:	011b      	lsls	r3, r3, #4
 2ae:	6013      	str	r3, [r2, #0]
	      delay();
 2b0:	f7ff ff92 	bl	1d8 <delay>
	  //Second Row     
	      FIO4SET = 0X00000d00;
 2b4:	4a61      	ldr	r2, [pc, #388]	(43c <.text+0x43c>)
 2b6:	23d0      	movs	r3, #208
 2b8:	011b      	lsls	r3, r3, #4
 2ba:	6013      	str	r3, [r2, #0]
	      key = FIO4PIN;
 2bc:	4b60      	ldr	r3, [pc, #384]	(440 <.text+0x440>)
 2be:	1c3a      	adds	r2, r7, #0
 2c0:	681b      	ldr	r3, [r3, #0]
 2c2:	6013      	str	r3, [r2, #0]
	      key = (key & 0xf000) >> 12 ;
 2c4:	1c3b      	adds	r3, r7, #0
 2c6:	681a      	ldr	r2, [r3, #0]
 2c8:	23f0      	movs	r3, #240
 2ca:	021b      	lsls	r3, r3, #8
 2cc:	4013      	ands	r3, r2
 2ce:	1c3a      	adds	r2, r7, #0
 2d0:	0b1b      	lsrs	r3, r3, #12
 2d2:	6013      	str	r3, [r2, #0]
      
      
	      if((key==0x07))
 2d4:	1c3b      	adds	r3, r7, #0
 2d6:	681b      	ldr	r3, [r3, #0]
 2d8:	2b07      	cmp	r3, #7
 2da:	d105      	bne.n	2e8 <key_routine+0xcc>
              {
	          send_serial_data('4');
 2dc:	2034      	movs	r0, #52
 2de:	f000 f8b5 	bl	44c <send_serial_data>
                  FIO3PIN = 0X00000004;
 2e2:	4a58      	ldr	r2, [pc, #352]	(444 <.text+0x444>)
 2e4:	2304      	movs	r3, #4
 2e6:	6013      	str	r3, [r2, #0]
              }
	      if((key==0x0b))
 2e8:	1c3b      	adds	r3, r7, #0
 2ea:	681b      	ldr	r3, [r3, #0]
 2ec:	2b0b      	cmp	r3, #11
 2ee:	d105      	bne.n	2fc <key_routine+0xe0>
              {
	          send_serial_data('5');
 2f0:	2035      	movs	r0, #53
 2f2:	f000 f8ab 	bl	44c <send_serial_data>
        	  FIO3PIN = 0X00000005;
 2f6:	4a53      	ldr	r2, [pc, #332]	(444 <.text+0x444>)
 2f8:	2305      	movs	r3, #5
 2fa:	6013      	str	r3, [r2, #0]
              }
    	      if( (key==0x0d))
 2fc:	1c3b      	adds	r3, r7, #0
 2fe:	681b      	ldr	r3, [r3, #0]
 300:	2b0d      	cmp	r3, #13
 302:	d105      	bne.n	310 <key_routine+0xf4>
              {
                  send_serial_data('6');
 304:	2036      	movs	r0, #54
 306:	f000 f8a1 	bl	44c <send_serial_data>
	          FIO3PIN = 0X00000006;
 30a:	4a4e      	ldr	r2, [pc, #312]	(444 <.text+0x444>)
 30c:	2306      	movs	r3, #6
 30e:	6013      	str	r3, [r2, #0]
	      }
              if( (key==0x0e))
 310:	1c3b      	adds	r3, r7, #0
 312:	681b      	ldr	r3, [r3, #0]
 314:	2b0e      	cmp	r3, #14
 316:	d105      	bne.n	324 <key_routine+0x108>
	      {
        	  send_serial_data('7');
 318:	2037      	movs	r0, #55
 31a:	f000 f897 	bl	44c <send_serial_data>
	          FIO3PIN = 0X00000007;
 31e:	4a49      	ldr	r2, [pc, #292]	(444 <.text+0x444>)
 320:	2307      	movs	r3, #7
 322:	6013      	str	r3, [r2, #0]
	      }
	      FIO4CLR = 0X00000d00;
 324:	4a48      	ldr	r2, [pc, #288]	(448 <.text+0x448>)
 326:	23d0      	movs	r3, #208
 328:	011b      	lsls	r3, r3, #4
 32a:	6013      	str	r3, [r2, #0]
	      delay();  
 32c:	f7ff ff54 	bl	1d8 <delay>
	      
 	//Third Row
     	      FIO4SET = 0X00000b00;
 330:	4a42      	ldr	r2, [pc, #264]	(43c <.text+0x43c>)
 332:	23b0      	movs	r3, #176
 334:	011b      	lsls	r3, r3, #4
 336:	6013      	str	r3, [r2, #0]
              key = FIO4PIN;
 338:	4b41      	ldr	r3, [pc, #260]	(440 <.text+0x440>)
 33a:	1c3a      	adds	r2, r7, #0
 33c:	681b      	ldr	r3, [r3, #0]
 33e:	6013      	str	r3, [r2, #0]
              key = (key & 0xf000) >> 12 ;
 340:	1c3b      	adds	r3, r7, #0
 342:	681a      	ldr	r2, [r3, #0]
 344:	23f0      	movs	r3, #240
 346:	021b      	lsls	r3, r3, #8
 348:	4013      	ands	r3, r2
 34a:	1c3a      	adds	r2, r7, #0
 34c:	0b1b      	lsrs	r3, r3, #12
 34e:	6013      	str	r3, [r2, #0]
  
              if((key==0x07))
 350:	1c3b      	adds	r3, r7, #0
 352:	681b      	ldr	r3, [r3, #0]
 354:	2b07      	cmp	r3, #7
 356:	d105      	bne.n	364 <key_routine+0x148>
              {
         	  send_serial_data('8');
 358:	2038      	movs	r0, #56
 35a:	f000 f877 	bl	44c <send_serial_data>
	          FIO3PIN = 0X00000008;
 35e:	4a39      	ldr	r2, [pc, #228]	(444 <.text+0x444>)
 360:	2308      	movs	r3, #8
 362:	6013      	str	r3, [r2, #0]
              }
	      if((key==0x0b))
 364:	1c3b      	adds	r3, r7, #0
 366:	681b      	ldr	r3, [r3, #0]
 368:	2b0b      	cmp	r3, #11
 36a:	d105      	bne.n	378 <key_routine+0x15c>
              {
	           send_serial_data('9');
 36c:	2039      	movs	r0, #57
 36e:	f000 f86d 	bl	44c <send_serial_data>
                   FIO3PIN = 0X00000009;
 372:	4a34      	ldr	r2, [pc, #208]	(444 <.text+0x444>)
 374:	2309      	movs	r3, #9
 376:	6013      	str	r3, [r2, #0]
              }
	      if( (key==0x0d))
 378:	1c3b      	adds	r3, r7, #0
 37a:	681b      	ldr	r3, [r3, #0]
 37c:	2b0d      	cmp	r3, #13
 37e:	d105      	bne.n	38c <key_routine+0x170>
              {
	          send_serial_data('a');
 380:	2061      	movs	r0, #97
 382:	f000 f863 	bl	44c <send_serial_data>
                  FIO3PIN = 0X0000000a;
 386:	4a2f      	ldr	r2, [pc, #188]	(444 <.text+0x444>)
 388:	230a      	movs	r3, #10
 38a:	6013      	str	r3, [r2, #0]
              }
              if( (key==0x0e))
 38c:	1c3b      	adds	r3, r7, #0
 38e:	681b      	ldr	r3, [r3, #0]
 390:	2b0e      	cmp	r3, #14
 392:	d105      	bne.n	3a0 <key_routine+0x184>
              {
          	  send_serial_data('b');
 394:	2062      	movs	r0, #98
 396:	f000 f859 	bl	44c <send_serial_data>
	          FIO3PIN = 0X0000000b;
 39a:	4a2a      	ldr	r2, [pc, #168]	(444 <.text+0x444>)
 39c:	230b      	movs	r3, #11
 39e:	6013      	str	r3, [r2, #0]
              }
              FIO4CLR = 0X00000b00;
 3a0:	4a29      	ldr	r2, [pc, #164]	(448 <.text+0x448>)
 3a2:	23b0      	movs	r3, #176
 3a4:	011b      	lsls	r3, r3, #4
 3a6:	6013      	str	r3, [r2, #0]
              delay();
 3a8:	f7ff ff16 	bl	1d8 <delay>
       //Fourth Row   
   	      FIO4SET = 0X00000700;
 3ac:	4a23      	ldr	r2, [pc, #140]	(43c <.text+0x43c>)
 3ae:	23e0      	movs	r3, #224
 3b0:	00db      	lsls	r3, r3, #3
 3b2:	6013      	str	r3, [r2, #0]
	      key = FIO4PIN;
 3b4:	4b22      	ldr	r3, [pc, #136]	(440 <.text+0x440>)
 3b6:	1c3a      	adds	r2, r7, #0
 3b8:	681b      	ldr	r3, [r3, #0]
 3ba:	6013      	str	r3, [r2, #0]
	      key = (key & 0xf000) >> 12 ;
 3bc:	1c3b      	adds	r3, r7, #0
 3be:	681a      	ldr	r2, [r3, #0]
 3c0:	23f0      	movs	r3, #240
 3c2:	021b      	lsls	r3, r3, #8
 3c4:	4013      	ands	r3, r2
 3c6:	1c3a      	adds	r2, r7, #0
 3c8:	0b1b      	lsrs	r3, r3, #12
 3ca:	6013      	str	r3, [r2, #0]
      
	      if((key==0x07))
 3cc:	1c3b      	adds	r3, r7, #0
 3ce:	681b      	ldr	r3, [r3, #0]
 3d0:	2b07      	cmp	r3, #7
 3d2:	d105      	bne.n	3e0 <key_routine+0x1c4>
              {
           	  send_serial_data('c');
 3d4:	2063      	movs	r0, #99
 3d6:	f000 f839 	bl	44c <send_serial_data>
               	  FIO3PIN = 0X0000000c;
 3da:	4a1a      	ldr	r2, [pc, #104]	(444 <.text+0x444>)
 3dc:	230c      	movs	r3, #12
 3de:	6013      	str	r3, [r2, #0]
              }
              if((key==0x0b))
 3e0:	1c3b      	adds	r3, r7, #0
 3e2:	681b      	ldr	r3, [r3, #0]
 3e4:	2b0b      	cmp	r3, #11
 3e6:	d105      	bne.n	3f4 <key_routine+0x1d8>
              {
                  send_serial_data('d');
 3e8:	2064      	movs	r0, #100
 3ea:	f000 f82f 	bl	44c <send_serial_data>
                  FIO3PIN = 0X0000000d;
 3ee:	4a15      	ldr	r2, [pc, #84]	(444 <.text+0x444>)
 3f0:	230d      	movs	r3, #13
 3f2:	6013      	str	r3, [r2, #0]
              }
              if((key==0x0d))
 3f4:	1c3b      	adds	r3, r7, #0
 3f6:	681b      	ldr	r3, [r3, #0]
 3f8:	2b0d      	cmp	r3, #13
 3fa:	d105      	bne.n	408 <Stack_Size+0x8>
              {
                  send_serial_data('e');
 3fc:	2065      	movs	r0, #101
 3fe:	f000 f825 	bl	44c <send_serial_data>
                  FIO3PIN = 0X0000000e;
 402:	4a10      	ldr	r2, [pc, #64]	(444 <.text+0x444>)
 404:	230e      	movs	r3, #14
 406:	6013      	str	r3, [r2, #0]
              }
              if( (key==0x0e))
 408:	1c3b      	adds	r3, r7, #0
 40a:	681b      	ldr	r3, [r3, #0]
 40c:	2b0e      	cmp	r3, #14
 40e:	d105      	bne.n	41c <Stack_Size+0x1c>
              {
       		  send_serial_data('f');
 410:	2066      	movs	r0, #102
 412:	f000 f81b 	bl	44c <send_serial_data>
                  FIO3PIN = 0X0000000f;
 416:	4a0b      	ldr	r2, [pc, #44]	(444 <.text+0x444>)
 418:	230f      	movs	r3, #15
 41a:	6013      	str	r3, [r2, #0]
              }
   	      FIO4CLR = 0X00000700;
 41c:	4a0a      	ldr	r2, [pc, #40]	(448 <.text+0x448>)
 41e:	23e0      	movs	r3, #224
 420:	00db      	lsls	r3, r3, #3
 422:	6013      	str	r3, [r2, #0]
              delay();
 424:	f7ff fed8 	bl	1d8 <delay>
	}
 428:	e706      	b.n	238 <key_routine+0x1c>
 42a:	0000      	lsls	r0, r0, #0
 42c:	c060      	stmia	r0!, {r5, r6}
 42e:	3fff      	subs	r7, #255
 430:	00ff      	lsls	r7, r7, #3
 432:	0080      	lsls	r0, r0, #2
 434:	c000      	stmia	r0!, {}
 436:	e002      	b.n	43e <.text+0x43e>
 438:	8008      	strh	r0, [r1, #0]
 43a:	e002      	b.n	442 <.text+0x442>
 43c:	c098      	stmia	r0!, {r3, r4, r7}
 43e:	3fff      	subs	r7, #255
 440:	c094      	stmia	r0!, {r2, r4, r7}
 442:	3fff      	subs	r7, #255
 444:	c074      	stmia	r0!, {r2, r4, r5, r6}
 446:	3fff      	subs	r7, #255
 448:	c09c      	stmia	r0!, {r2, r3, r4, r7}
 44a:	3fff      	subs	r7, #255

0000044c <send_serial_data>:
}
void send_serial_data(int ch)
{
 44c:	b580      	push	{r7, lr}
 44e:	b081      	sub	sp, #4
 450:	af00      	add	r7, sp, #0
 452:	1c3b      	adds	r3, r7, #0
 454:	6018      	str	r0, [r3, #0]
  while ((U0LSR & 0x20)!=0x20);
 456:	4b07      	ldr	r3, [pc, #28]	(474 <.text+0x474>)
 458:	681a      	ldr	r2, [r3, #0]
 45a:	2320      	movs	r3, #32
 45c:	4013      	ands	r3, r2
 45e:	2b00      	cmp	r3, #0
 460:	d0f9      	beq.n	456 <send_serial_data+0xa>
  U0THR = ch;
 462:	4b05      	ldr	r3, [pc, #20]	(478 <.text+0x478>)
 464:	1c3a      	adds	r2, r7, #0
 466:	6812      	ldr	r2, [r2, #0]
 468:	601a      	str	r2, [r3, #0]
}
 46a:	46bd      	mov	sp, r7
 46c:	b001      	add	sp, #4
 46e:	bc80      	pop	{r7}
 470:	bc01      	pop	{r0}
 472:	4700      	bx	r0
 474:	c014      	stmia	r0!, {r2, r4}
 476:	e000      	b.n	47a <.text+0x47a>
 478:	c000      	stmia	r0!, {}
 47a:	e000      	b.n	47e <main+0x2>

0000047c <main>:
int main (void)
{
 47c:	b580      	push	{r7, lr}
 47e:	b081      	sub	sp, #4
 480:	af00      	add	r7, sp, #0
	unsigned int Fdiv;
	FIO4DIR = 0XFF000fff;
 482:	4a18      	ldr	r2, [pc, #96]	(4e4 <.text+0x4e4>)
 484:	4b18      	ldr	r3, [pc, #96]	(4e8 <.text+0x4e8>)
 486:	6013      	str	r3, [r2, #0]
	init_timer( ((72000000/100) - 1 ));
 488:	4b18      	ldr	r3, [pc, #96]	(4ec <.text+0x4ec>)
 48a:	1c18      	adds	r0, r3, #0
 48c:	f000 f8a6 	bl	5dc <init_timer>
	PINSEL0 = 0x00000050;   
 490:	4a17      	ldr	r2, [pc, #92]	(4f0 <.text+0x4f0>)
 492:	2350      	movs	r3, #80
 494:	6013      	str	r3, [r2, #0]
	U0LCR = 0x83;               // 8 bits, no Parity, 1 Stop bit  
 496:	4a17      	ldr	r2, [pc, #92]	(4f4 <.text+0x4f4>)
 498:	2383      	movs	r3, #131
 49a:	6013      	str	r3, [r2, #0]
	Fdiv = ( 72000000 / 16 ) / 19200 ;  //baud rate  
 49c:	1c3a      	adds	r2, r7, #0
 49e:	23ea      	movs	r3, #234
 4a0:	6013      	str	r3, [r2, #0]
	U0DLM = Fdiv / 256;
 4a2:	4a15      	ldr	r2, [pc, #84]	(4f8 <.text+0x4f8>)
 4a4:	1c3b      	adds	r3, r7, #0
 4a6:	681b      	ldr	r3, [r3, #0]
 4a8:	0a1b      	lsrs	r3, r3, #8
 4aa:	6013      	str	r3, [r2, #0]
	U0DLL = Fdiv % 256;
 4ac:	4913      	ldr	r1, [pc, #76]	(4fc <.text+0x4fc>)
 4ae:	1c3b      	adds	r3, r7, #0
 4b0:	681a      	ldr	r2, [r3, #0]
 4b2:	23ff      	movs	r3, #255
 4b4:	4013      	ands	r3, r2
 4b6:	600b      	str	r3, [r1, #0]
   	U0LCR = 0x03;               // DLAB = 0
 4b8:	4a0e      	ldr	r2, [pc, #56]	(4f4 <.text+0x4f4>)
 4ba:	2303      	movs	r3, #3
 4bc:	6013      	str	r3, [r2, #0]
	send_serial_data('Z');
 4be:	205a      	movs	r0, #90
 4c0:	f7ff ffc4 	bl	44c <send_serial_data>
	send_serial_data(0x0d);
 4c4:	200d      	movs	r0, #13
 4c6:	f7ff ffc1 	bl	44c <send_serial_data>
	send_serial_data(0x0a);
 4ca:	200a      	movs	r0, #10
 4cc:	f7ff ffbe 	bl	44c <send_serial_data>
	key_routine();
 4d0:	f7ff fea4 	bl	21c <key_routine>
	return(0);
 4d4:	2300      	movs	r3, #0
}
 4d6:	1c18      	adds	r0, r3, #0
 4d8:	46bd      	mov	sp, r7
 4da:	b001      	add	sp, #4
 4dc:	bc80      	pop	{r7}
 4de:	bc02      	pop	{r1}
 4e0:	4708      	bx	r1
 4e2:	0000      	lsls	r0, r0, #0
 4e4:	c080      	stmia	r0!, {r7}
 4e6:	3fff      	subs	r7, #255
 4e8:	0fff      	lsrs	r7, r7, #31
 4ea:	ff00 fc7f 	undefined
 4ee:	000a      	lsls	r2, r1, #0
 4f0:	c000      	stmia	r0!, {}
 4f2:	e002      	b.n	4fa <.text+0x4fa>
 4f4:	c00c      	stmia	r0!, {r2, r3}
 4f6:	e000      	b.n	4fa <.text+0x4fa>
 4f8:	c004      	stmia	r0!, {r2}
 4fa:	e000      	b.n	4fe <.text+0x4fe>
 4fc:	c000      	stmia	r0!, {}
 4fe:	e000      	b.n	502 <install_irq+0x2>

00000500 <install_irq>:
** Returned value:		true or false, return false if IntNum is out of range
** 
******************************************************************************/
int install_irq( int IntNumber, void *HandlerAddr, int Priority )
{
 500:	b580      	push	{r7, lr}
 502:	b086      	sub	sp, #24
 504:	af00      	add	r7, sp, #0
 506:	1c3b      	adds	r3, r7, #0
 508:	330c      	adds	r3, #12
 50a:	6018      	str	r0, [r3, #0]
 50c:	1c3b      	adds	r3, r7, #0
 50e:	3308      	adds	r3, #8
 510:	6019      	str	r1, [r3, #0]
 512:	1d3b      	adds	r3, r7, #4
 514:	601a      	str	r2, [r3, #0]
    int *vect_addr;
    int *vect_cntl;
      
    VICIntEnClr = 1 << IntNumber;	/* Disable Interrupt */
 516:	4921      	ldr	r1, [pc, #132]	(59c <.text+0x59c>)
 518:	1c3b      	adds	r3, r7, #0
 51a:	330c      	adds	r3, #12
 51c:	2201      	movs	r2, #1
 51e:	681b      	ldr	r3, [r3, #0]
 520:	1c10      	adds	r0, r2, #0
 522:	4098      	lsls	r0, r3
 524:	1c03      	adds	r3, r0, #0
 526:	600b      	str	r3, [r1, #0]
    if ( IntNumber >= 32 )
 528:	1c3b      	adds	r3, r7, #0
 52a:	330c      	adds	r3, #12
 52c:	681b      	ldr	r3, [r3, #0]
 52e:	2b1f      	cmp	r3, #31
 530:	dd02      	ble.n	538 <install_irq+0x38>
    {
		return ( FALSE );
 532:	2100      	movs	r1, #0
 534:	6039      	str	r1, [r7, #0]
 536:	e029      	b.n	58c <install_irq+0x8c>
    }
    else
    {
		/* find first un-assigned VIC address for the handler */
		vect_addr = (int *)(VIC_BASE_ADDR + VECT_ADDR_INDEX + IntNumber*4);
 538:	1c3b      	adds	r3, r7, #0
 53a:	330c      	adds	r3, #12
 53c:	681b      	ldr	r3, [r3, #0]
 53e:	009b      	lsls	r3, r3, #2
 540:	4817      	ldr	r0, [pc, #92]	(5a0 <.text+0x5a0>)
 542:	181a      	adds	r2, r3, r0
 544:	1c3b      	adds	r3, r7, #0
 546:	3310      	adds	r3, #16
 548:	601a      	str	r2, [r3, #0]
		vect_cntl = (int *)(VIC_BASE_ADDR + VECT_CNTL_INDEX + IntNumber*4);
 54a:	1c3b      	adds	r3, r7, #0
 54c:	330c      	adds	r3, #12
 54e:	681b      	ldr	r3, [r3, #0]
 550:	009b      	lsls	r3, r3, #2
 552:	4914      	ldr	r1, [pc, #80]	(5a4 <.text+0x5a4>)
 554:	185a      	adds	r2, r3, r1
 556:	1c3b      	adds	r3, r7, #0
 558:	3314      	adds	r3, #20
 55a:	601a      	str	r2, [r3, #0]
		*vect_addr = (int)HandlerAddr;	/* set interrupt vector */
 55c:	1c3b      	adds	r3, r7, #0
 55e:	3308      	adds	r3, #8
 560:	681a      	ldr	r2, [r3, #0]
 562:	1c3b      	adds	r3, r7, #0
 564:	3310      	adds	r3, #16
 566:	681b      	ldr	r3, [r3, #0]
 568:	601a      	str	r2, [r3, #0]
		*vect_cntl = Priority;
 56a:	1c3b      	adds	r3, r7, #0
 56c:	3314      	adds	r3, #20
 56e:	681a      	ldr	r2, [r3, #0]
 570:	1d3b      	adds	r3, r7, #4
 572:	681b      	ldr	r3, [r3, #0]
 574:	6013      	str	r3, [r2, #0]
		VICIntEnable = 1 << IntNumber;	/* Enable Interrupt */
 576:	490c      	ldr	r1, [pc, #48]	(5a8 <.text+0x5a8>)
 578:	1c3b      	adds	r3, r7, #0
 57a:	330c      	adds	r3, #12
 57c:	2201      	movs	r2, #1
 57e:	681b      	ldr	r3, [r3, #0]
 580:	1c10      	adds	r0, r2, #0
 582:	4098      	lsls	r0, r3
 584:	1c03      	adds	r3, r0, #0
 586:	600b      	str	r3, [r1, #0]
		return( TRUE );
 588:	2101      	movs	r1, #1
 58a:	6039      	str	r1, [r7, #0]
 58c:	683b      	ldr	r3, [r7, #0]
    }
}
 58e:	1c18      	adds	r0, r3, #0
 590:	46bd      	mov	sp, r7
 592:	b006      	add	sp, #24
 594:	bc80      	pop	{r7}
 596:	bc02      	pop	{r1}
 598:	4708      	bx	r1
 59a:	0000      	lsls	r0, r0, #0
 59c:	f014 ffff 	bl	1559e <VIC_VectAddr+0x1469e>
 5a0:	f100 ffff 	bl	1015a2 <VIC_VectAddr+0x1006a2>
 5a4:	f200 ffff 	bl	2015a6 <VIC_VectAddr+0x2006a6>
 5a8:	f010 ffff 	bl	115aa <VIC_VectAddr+0x106aa>

000005ac <Timer0Handler>:

/******************************************************************************
** Function name:		Timer0Handler
**
** Descriptions:		Timer/Counter 0 interrupt handler
**				executes each 10ms @ 60 MHz CPU Clock
**
** parameters:			None
** Returned value:		None
** 
******************************************************************************/
#ifdef __GNUC__
void Timer0Handler (void); // avoid missing proto warning - mthomas
#endif
void Timer0Handler (void) __irq 
{  
 5ac:	b580      	push	{r7, lr}
 5ae:	af02      	add	r7, sp, #8
    T0IR = 1;			/* clear interrupt flag */
 5b0:	4a07      	ldr	r2, [pc, #28]	(5d0 <.text+0x5d0>)
 5b2:	2301      	movs	r3, #1
 5b4:	6013      	str	r3, [r2, #0]
    IENABLE;			/* handles nested interrupt */

    timer_counter++;
 5b6:	4b07      	ldr	r3, [pc, #28]	(5d4 <.text+0x5d4>)
 5b8:	681b      	ldr	r3, [r3, #0]
 5ba:	1c5a      	adds	r2, r3, #1
 5bc:	4b05      	ldr	r3, [pc, #20]	(5d4 <.text+0x5d4>)
 5be:	601a      	str	r2, [r3, #0]

    IDISABLE;
    VICVectAddr = 0;		/* Acknowledge Interrupt */
 5c0:	4a05      	ldr	r2, [pc, #20]	(5d8 <.text+0x5d8>)
 5c2:	2300      	movs	r3, #0
 5c4:	6013      	str	r3, [r2, #0]
}
 5c6:	46bd      	mov	sp, r7
 5c8:	b082      	sub	sp, #8
 5ca:	bc80      	pop	{r7}
 5cc:	bc01      	pop	{r0}
 5ce:	4700      	bx	r0
 5d0:	4000      	ands	r0, r0
 5d2:	e000      	b.n	5d6 <.text+0x5d6>
 5d4:	0000      	lsls	r0, r0, #0
 5d6:	4000      	ands	r0, r0
 5d8:	ff00 ffff 	undefined

000005dc <init_timer>:

/******************************************************************************
** Function name:		enable_timer
**
** Descriptions:		Enable timer
**
** parameters:			timer number: 0 or 1
** Returned value:		None
** 
******************************************************************************/
void enable_timer( char timer_num )
{
    if ( timer_num == 0 )
    {
		T0TCR = 1;
    }
    else
    {
		T1TCR = 1;
    }
    return;
}

/******************************************************************************
** Function name:		disable_timer
**
** Descriptions:		Disable timer
**
** parameters:			timer number: 0 or 1
** Returned value:		None
** 
******************************************************************************/
void disable_timer( char timer_num )
{
    if ( timer_num == 0 )
    {
		T0TCR = 0;
    }
    else
    {
		T1TCR = 0;
    }
    return;
}

/******************************************************************************
** Function name:		reset_timer
**
** Descriptions:		Reset timer
**
** parameters:			timer number: 0 or 1
** Returned value:		None
** 
******************************************************************************/
void reset_timer( char timer_num )
{
    int regVal;

    if ( timer_num == 0 )
    {
		regVal = T0TCR;
		regVal |= 0x02;
		T0TCR = regVal;
    }
    else
    {
		regVal = T1TCR;
		regVal |= 0x02;
		T1TCR = regVal;
    }
    return;
} 

/******************************************************************************
** Function name:		init_timer
**
** Descriptions:		Initialize timer, set timer interval, reset timer,
**						install timer interrupt handler
**
** parameters:			None
** Returned value:		true or false, if the interrupt handler can't be
**						installed, return false.
** 
******************************************************************************/
int init_timer ( int TimerInterval ) 
{
 5dc:	b580      	push	{r7, lr}
 5de:	b082      	sub	sp, #8
 5e0:	af00      	add	r7, sp, #0
 5e2:	1d3b      	adds	r3, r7, #4
 5e4:	6018      	str	r0, [r3, #0]
    timer_counter = 0;
 5e6:	4a0f      	ldr	r2, [pc, #60]	(624 <.text+0x624>)
 5e8:	2300      	movs	r3, #0
 5ea:	6013      	str	r3, [r2, #0]
    T0MR0 = TimerInterval;
 5ec:	4a0e      	ldr	r2, [pc, #56]	(628 <.text+0x628>)
 5ee:	1d3b      	adds	r3, r7, #4
 5f0:	681b      	ldr	r3, [r3, #0]
 5f2:	6013      	str	r3, [r2, #0]
    T0MCR = 3;				/* Interrupt and Reset on MR0*/ 
 5f4:	4a0d      	ldr	r2, [pc, #52]	(62c <.text+0x62c>)
 5f6:	2303      	movs	r3, #3
 5f8:	6013      	str	r3, [r2, #0]
    if ( install_irq( 4, (void *)Timer0Handler, 0x01 ) == FALSE )
 5fa:	4b0d      	ldr	r3, [pc, #52]	(630 <.text+0x630>)
 5fc:	2004      	movs	r0, #4
 5fe:	1c19      	adds	r1, r3, #0
 600:	2201      	movs	r2, #1
 602:	f7ff ff7d 	bl	500 <install_irq>
 606:	1c03      	adds	r3, r0, #0
 608:	2b00      	cmp	r3, #0
 60a:	d102      	bne.n	612 <init_timer+0x36>
    {
		return (FALSE);
 60c:	2300      	movs	r3, #0
 60e:	603b      	str	r3, [r7, #0]
 610:	e001      	b.n	616 <init_timer+0x3a>
    }
   else
    {
		return (TRUE);
 612:	2301      	movs	r3, #1
 614:	603b      	str	r3, [r7, #0]
 616:	683b      	ldr	r3, [r7, #0]
    }
}
 618:	1c18      	adds	r0, r3, #0
 61a:	46bd      	mov	sp, r7
 61c:	b002      	add	sp, #8
 61e:	bc80      	pop	{r7}
 620:	bc02      	pop	{r1}
 622:	4708      	bx	r1
 624:	0000      	lsls	r0, r0, #0
 626:	4000      	ands	r0, r0
 628:	4018      	ands	r0, r3
 62a:	e000      	b.n	62e <.text+0x62e>
 62c:	4014      	ands	r4, r2
 62e:	e000      	b.n	632 <.text+0x632>
 630:	05ad      	lsls	r5, r5, #22
	...

00000634 <TargetResetInit>:
/***********************To set peripheral clock and processor clock**************************/
void  TargetResetInit(void)
{
 634:	b580      	push	{r7, lr}
 636:	af02      	add	r7, sp, #8
  // 72 Mhz Frequency
  if ((PLLSTAT & 0x02000000) > 0)
 638:	4b3f      	ldr	r3, [pc, #252]	(738 <.text+0x738>)
 63a:	681a      	ldr	r2, [r3, #0]
 63c:	2380      	movs	r3, #128
 63e:	049b      	lsls	r3, r3, #18
 640:	4013      	ands	r3, r2
 642:	2b00      	cmp	r3, #0
 644:	d00d      	beq.n	662 <TargetResetInit+0x2e>
  {
      /* If the PLL is already running   */
      PLLCON  &= ~0x02;                          /* Disconnect the PLL                                       */
 646:	493d      	ldr	r1, [pc, #244]	(73c <.text+0x73c>)
 648:	4b3c      	ldr	r3, [pc, #240]	(73c <.text+0x73c>)
 64a:	681a      	ldr	r2, [r3, #0]
 64c:	2302      	movs	r3, #2
 64e:	1c10      	adds	r0, r2, #0
 650:	4398      	bics	r0, r3
 652:	1c03      	adds	r3, r0, #0
 654:	600b      	str	r3, [r1, #0]
      PLLFEED  =  0xAA;                          /* PLL register update sequence, 0xAA, 0x55                 */
 656:	4a3a      	ldr	r2, [pc, #232]	(740 <.text+0x740>)
 658:	23aa      	movs	r3, #170
 65a:	6013      	str	r3, [r2, #0]
      PLLFEED  =  0x55;
 65c:	4a38      	ldr	r2, [pc, #224]	(740 <.text+0x740>)
 65e:	2355      	movs	r3, #85
 660:	6013      	str	r3, [r2, #0]
  }
  PLLCON   &= ~0x01;                            /* Disable the PLL                                          */
 662:	4936      	ldr	r1, [pc, #216]	(73c <.text+0x73c>)
 664:	4b35      	ldr	r3, [pc, #212]	(73c <.text+0x73c>)
 666:	681a      	ldr	r2, [r3, #0]
 668:	2301      	movs	r3, #1
 66a:	1c10      	adds	r0, r2, #0
 66c:	4398      	bics	r0, r3
 66e:	1c03      	adds	r3, r0, #0
 670:	600b      	str	r3, [r1, #0]
  PLLFEED   =  0xAA;                           /* PLL register update sequence, 0xAA, 0x55                 */
 672:	4a33      	ldr	r2, [pc, #204]	(740 <.text+0x740>)
 674:	23aa      	movs	r3, #170
 676:	6013      	str	r3, [r2, #0]
  PLLFEED   =  0x55;
 678:	4a31      	ldr	r2, [pc, #196]	(740 <.text+0x740>)
 67a:	2355      	movs	r3, #85
 67c:	6013      	str	r3, [r2, #0]
  SCS      &= ~0x10;                         /* OSCRANGE = 0, Main OSC is between 1 and 20 Mhz           */
 67e:	4931      	ldr	r1, [pc, #196]	(744 <.text+0x744>)
 680:	4b30      	ldr	r3, [pc, #192]	(744 <.text+0x744>)
 682:	681a      	ldr	r2, [r3, #0]
 684:	2310      	movs	r3, #16
 686:	1c10      	adds	r0, r2, #0
 688:	4398      	bics	r0, r3
 68a:	1c03      	adds	r3, r0, #0
 68c:	600b      	str	r3, [r1, #0]
  SCS      |=  0x20;                         /* OSCEN = 1, Enable the main oscillator                    */
 68e:	492d      	ldr	r1, [pc, #180]	(744 <.text+0x744>)
 690:	4b2c      	ldr	r3, [pc, #176]	(744 <.text+0x744>)
 692:	681a      	ldr	r2, [r3, #0]
 694:	2320      	movs	r3, #32
 696:	4313      	orrs	r3, r2
 698:	600b      	str	r3, [r1, #0]
  while ((SCS &  0x40) == 0);
 69a:	4b2a      	ldr	r3, [pc, #168]	(744 <.text+0x744>)
 69c:	681a      	ldr	r2, [r3, #0]
 69e:	2340      	movs	r3, #64
 6a0:	4013      	ands	r3, r2
 6a2:	2b00      	cmp	r3, #0
 6a4:	d0f9      	beq.n	69a <TargetResetInit+0x66>
  CLKSRCSEL = 0x01;                         /* Select main OSC, 12MHz, as the PLL clock source          */
 6a6:	4a28      	ldr	r2, [pc, #160]	(748 <.text+0x748>)
 6a8:	2301      	movs	r3, #1
 6aa:	6013      	str	r3, [r2, #0]
  PLLCFG    = (24 << 0) | (1 << 16);         /* Configure the PLL multiplier and divider                 */   
 6ac:	4a27      	ldr	r2, [pc, #156]	(74c <.text+0x74c>)
 6ae:	4b28      	ldr	r3, [pc, #160]	(750 <.text+0x750>)
 6b0:	6013      	str	r3, [r2, #0]
  PLLFEED   = 0xAA;                         /* PLL register update sequence, 0xAA, 0x55                 */
 6b2:	4a23      	ldr	r2, [pc, #140]	(740 <.text+0x740>)
 6b4:	23aa      	movs	r3, #170
 6b6:	6013      	str	r3, [r2, #0]
  PLLFEED   = 0x55;
 6b8:	4a21      	ldr	r2, [pc, #132]	(740 <.text+0x740>)
 6ba:	2355      	movs	r3, #85
 6bc:	6013      	str	r3, [r2, #0]
  PLLCON   |= 0x01;                        /* Enable the PLL                                           */
 6be:	491f      	ldr	r1, [pc, #124]	(73c <.text+0x73c>)
 6c0:	4b1e      	ldr	r3, [pc, #120]	(73c <.text+0x73c>)
 6c2:	681a      	ldr	r2, [r3, #0]
 6c4:	2301      	movs	r3, #1
 6c6:	4313      	orrs	r3, r2
 6c8:	600b      	str	r3, [r1, #0]
  PLLFEED   = 0xAA;                        /* PLL register update sequence, 0xAA, 0x55                 */
 6ca:	4a1d      	ldr	r2, [pc, #116]	(740 <.text+0x740>)
 6cc:	23aa      	movs	r3, #170
 6ce:	6013      	str	r3, [r2, #0]
  PLLFEED   = 0x55;
 6d0:	4a1b      	ldr	r2, [pc, #108]	(740 <.text+0x740>)
 6d2:	2355      	movs	r3, #85
 6d4:	6013      	str	r3, [r2, #0]
  CCLKCFG   = 3;                        /* Configure the ARM Core Processor clock divider           */
 6d6:	4a1f      	ldr	r2, [pc, #124]	(754 <.text+0x754>)
 6d8:	2303      	movs	r3, #3
 6da:	6013      	str	r3, [r2, #0]
  USBCLKCFG = 5;                    /* Configure the USB clock divider                          */
 6dc:	4a1e      	ldr	r2, [pc, #120]	(758 <.text+0x758>)
 6de:	2305      	movs	r3, #5
 6e0:	6013      	str	r3, [r2, #0]
  while ((PLLSTAT & 0x04000000) == 0);  
 6e2:	4b15      	ldr	r3, [pc, #84]	(738 <.text+0x738>)
 6e4:	681a      	ldr	r2, [r3, #0]
 6e6:	2380      	movs	r3, #128
 6e8:	04db      	lsls	r3, r3, #19
 6ea:	4013      	ands	r3, r2
 6ec:	2b00      	cmp	r3, #0
 6ee:	d0f8      	beq.n	6e2 <TargetResetInit+0xae>
  PCLKSEL0  = 0xAAAAAAAA;                     /* Set peripheral clocks to be half of main clock           */
 6f0:	4a1a      	ldr	r2, [pc, #104]	(75c <.text+0x75c>)
 6f2:	4b1b      	ldr	r3, [pc, #108]	(760 <.text+0x760>)
 6f4:	6013      	str	r3, [r2, #0]
  PCLKSEL1  = 0x22AAA8AA;
 6f6:	4a1b      	ldr	r2, [pc, #108]	(764 <.text+0x764>)
 6f8:	4b1b      	ldr	r3, [pc, #108]	(768 <.text+0x768>)
 6fa:	6013      	str	r3, [r2, #0]
  PLLCON   |= 0x02;                         /* Connect the PLL. The PLL is now the active clock source  */
 6fc:	490f      	ldr	r1, [pc, #60]	(73c <.text+0x73c>)
 6fe:	4b0f      	ldr	r3, [pc, #60]	(73c <.text+0x73c>)
 700:	681a      	ldr	r2, [r3, #0]
 702:	2302      	movs	r3, #2
 704:	4313      	orrs	r3, r2
 706:	600b      	str	r3, [r1, #0]
  PLLFEED   = 0xAA;                          /* PLL register update sequence, 0xAA, 0x55                 */
 708:	4a0d      	ldr	r2, [pc, #52]	(740 <.text+0x740>)
 70a:	23aa      	movs	r3, #170
 70c:	6013      	str	r3, [r2, #0]
  PLLFEED   = 0x55;
 70e:	4a0c      	ldr	r2, [pc, #48]	(740 <.text+0x740>)
 710:	2355      	movs	r3, #85
 712:	6013      	str	r3, [r2, #0]
  while ((PLLSTAT & 0x02000000) == 0);  
 714:	4b08      	ldr	r3, [pc, #32]	(738 <.text+0x738>)
 716:	681a      	ldr	r2, [r3, #0]
 718:	2380      	movs	r3, #128
 71a:	049b      	lsls	r3, r3, #18
 71c:	4013      	ands	r3, r2
 71e:	2b00      	cmp	r3, #0
 720:	d0f8      	beq.n	714 <TargetResetInit+0xe0>
  PCLKSEL0 = 0x55555555;  		     /* PCLK is the same as CCLK */
 722:	4a0e      	ldr	r2, [pc, #56]	(75c <.text+0x75c>)
 724:	4b11      	ldr	r3, [pc, #68]	(76c <.text+0x76c>)
 726:	6013      	str	r3, [r2, #0]
  PCLKSEL1 = 0x55555555;  
 728:	4a0e      	ldr	r2, [pc, #56]	(764 <.text+0x764>)
 72a:	4b10      	ldr	r3, [pc, #64]	(76c <.text+0x76c>)
 72c:	6013      	str	r3, [r2, #0]
}
 72e:	46bd      	mov	sp, r7
 730:	b082      	sub	sp, #8
 732:	bc80      	pop	{r7}
 734:	bc01      	pop	{r0}
 736:	4700      	bx	r0
 738:	c088      	stmia	r0!, {r3, r7}
 73a:	e01f      	b.n	77c <_edata+0xc>
 73c:	c080      	stmia	r0!, {r7}
 73e:	e01f      	b.n	780 <_edata+0x10>
 740:	c08c      	stmia	r0!, {r2, r3, r7}
 742:	e01f      	b.n	784 <_edata+0x14>
 744:	c1a0      	stmia	r1!, {r5, r7}
 746:	e01f      	b.n	788 <_edata+0x18>
 748:	c10c      	stmia	r1!, {r2, r3}
 74a:	e01f      	b.n	78c <_edata+0x1c>
 74c:	c084      	stmia	r0!, {r2, r7}
 74e:	e01f      	b.n	790 <_edata+0x20>
 750:	0018      	lsls	r0, r3, #0
 752:	0001      	lsls	r1, r0, #0
 754:	c104      	stmia	r1!, {r2}
 756:	e01f      	b.n	798 <_edata+0x28>
 758:	c108      	stmia	r1!, {r3}
 75a:	e01f      	b.n	79c <_edata+0x2c>
 75c:	c1a8      	stmia	r1!, {r3, r5, r7}
 75e:	e01f      	b.n	7a0 <_edata+0x30>
 760:	aaaa      	add	r2, sp, #680
 762:	aaaa      	add	r2, sp, #680
 764:	c1ac      	stmia	r1!, {r2, r3, r5, r7}
 766:	e01f      	b.n	7a8 <_edata+0x38>
 768:	a8aa      	add	r0, sp, #680
 76a:	22aa      	movs	r2, #170
 76c:	5555      	strb	r5, [r2, r5]
 76e:	5555      	strb	r5, [r2, r5]
